bind_tf_idf(SkillDescription, Description, Amount)
bind_tf_idf(all_data, SkillDescription)
library(wordcloud)
library(janeaustenr)
bind_tf_idf(all_data, SkillDescription)
library(janeaustenr)
bind_tf_idf(all_data, SkillDescription)
# number of samples, replications, and strata
n <- 10
M <- 200
k <- 8
m <- M / k
# range of interest: -1 to 1
a <- -1
b <- 1
s_width <- (b - a) / k # width of strata
# standard normal distribution
g_norm <- function(x) {
x^2 / sqrt(2 * pi) * exp(-x^2 / 2)
}
# containers for estimates
strat <- numeric(8)
mc_entire <- numeric(0)
mc_strat <- numeric(0)
# perform monte carlo integration
for (i in 1:n) {
# perform for entire range (a, b)
mc_entire <- c(mc_entire, mean(g_norm(runif(M, a, b))))
# perform for strata (a, b) / k
for (j in 1:k) {
samp <- g_norm(runif(m, a + (j - 1) * s_width, a + j * s_width))
strat[j] <- mean(samp)
}
mc_strat <- c(mc_strat, mean(strat))
}
# get results
var(mc_entire)
var(mc_strat)
matrix(0,50,2)
numeric(10)
m<-10000
x<-runif(m)
theta.hat <- mean(x^2)
print(theta.hat)
print(x^3/3)
m<-10000
x<-runif(m)
theta.hat <- mean(x^2)
print(theta.hat)
print(1^3/3)
m <- 10000
a <- - 12 + 6 * (1^3/3)
U <- runif(m)
T1 <- exp(U)
m <- 10000
a <- - 12 + 6 * (1^3/3)
U <- runif(m)
T1 <- exp(U) #simple MC
T2 <- exp(U) + a * (U - 1/2) #controlled
mean(T1)
mean(T2)
(var(T1) - var(T2)) / var(T1)
print(theta.hat)
print(1^3/3)
M1<-10000
x1<-runif(M1)
theta.hat <- mean(x1^2)
print(theta.hat)
print(1^3/3)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
(x^3)/3}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k))) estimates[i, 2] <- mean(T2)
}
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #nu
estimates <- matrix(0, N, 2)
g <- function(x) {
(x^3)/3*(x>0)*(x<1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k))) estimates[i, 2] <- mean(T2)
}
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
estimates
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
i<-1
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
i<-1
j<-1
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M))) for (j in 1:k)
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
(x^3)/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
(x^3)/3*(x>0)*(x<1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
View(estimates)
View(estimates)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3*x^3/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3+0.5
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
}
estimates[i, 2] <- mean(T2)
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
m = 10000
a = - 12 + 6 * (exp(1) - 1)
U = runif(m)
X = (U)^3/3
Y = U
muY = 0.5
Xb = mean(X)
Yb = mean(Y)
cs = -sum((X-Xb)*(Y-Yb))/sum((Y-Yb)^2)
Z = X + cs*(Y-muY)
print(Xb)
print(Yb)
print(Z)
print(Z)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3+0.5
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
killDbConnections <- function () {
all_cons <- dbListConnections(MySQL())
print(all_cons)
for(con in all_cons)
+  dbDisconnect(con)
print(paste(length(all_cons), " connections killed."))
}
#MonteCarlo
M1<-10000
x1<-runif(M1)
theta.hat <- mean(x1^2)
print(theta.hat)
print(1^3/3)
#strata
M <- 10000 #number of replicates
k <- 10 #number of strata
r <- M / k #replicates per stratum
N <- 50 #number of times to repeat the estimation T2 <- numeric(k)
estimates <- matrix(0, N, 2)
g <- function(x) {
x^3/3
}
for (i in 1:N) {
estimates[i, 1] <- mean(g(runif(M)))
for (j in 1:k){
T2[j] <- mean(g(runif(M/k, (j-1)/k, j/k)))
estimates[i, 2] <- mean(T2)
}
}
apply(estimates, 2, mean)
apply(estimates, 2, var)
install.packages(c("httr", "jsonlite", "lubridate"))
library(jsonlite)
library(XML)
library(knitr)
library(httr)
library(lubridate)
moviesreviews<-fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747")
head(moviesreviews)
asFrame <- do.call("rbind.fill", lapply(moviesreviews, as.data.frame))
head(asFrame)
moviesreviews<-fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747", nullValue = NA)
asFrame <- do.call("rbind.fill", lapply(moviesreviews, as.data.frame))
head(asFrame)
library(tidyr)
asFrame <- do.call("rbind.fill", lapply(moviesreviews, as.data.frame))
head(asFrame)
asFrame <- sapply(moviesreviews,rbind)
head(asFrame)
class(asFrame)
do.call("rbind", lapply(moviesreviews, data.frame))
library(tidry)
head(moviesreviews)
moviesreviews[[1]]
moviesreviews[1,
]
dim(moviesreviews)
typeof(moviesreviews)
moviesreviews$mpaa_rating
moviesreviews$mpaa_rating
fromJSON(moviesreviews) %>% as.data.frame
fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747", nullValue = NA) %>% as.data.frame()
test <- fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747", nullValue = NA) %>% as.data.frame()
test <- fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747") %>% as.data.frame()
View(test)
View(test)
moviesreviews <- fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747") %>% as.data.frame()
head(asFrame)
View(moviesreviews)
View(moviesreviews)
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
library(tidyr)
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
library(tidyr)
library(stringr)
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
library(jsonlite)
library(XML)
library(knitr)
library(httr)
library(lubridate)
library(tidyr)
library(stringr)
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
head(moviesreviews)
moviesreviews <- fromJSON("https://api.nytimes.com/svc/movies/v2/reviews/search.json?api-key=9f2d716acf3141258fe2426cf7079747") %>% as.data.frame()
head(moviesreviews)
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
head(moviesreviews)
moviesreviews[is.na(moviesreviews)]<-""
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
head(moviesreviews)
moviesreviews[(moviesreviews)="<NA>"]<-""
moviesreviews[(moviesreviews)=="<NA>"]<-""
moviesreviews[sapply(moviesreviews)=="<NA>"]<-""
moviesreviews[moviesreviews$results.opening_date=="<NA>"]<-""
moviesreviews[moviesreviews$results.opening_date="<NA>"]<-""
moviesreviews$results.opening_date[moviesreviews$results.opening_date="<NA>"]<-""
moviesreviews$results.opening_date
is.na(moviesreviews)
moviesreviews$results.opening_date[is.na(moviesreviews$results.opening_date)]<-""
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
moviesreviews$results.opening_date[is.na(moviesreviews$results.opening_date)]<-""
kable(head(moviesreviews), caption = "Table 1. NY Times Movie Reviews")
head(moviesreviews)
typeof(moviesreviews)
mMC.Phi <- function(x, R = 10000, antithetic = TRUE) { u <- runif(R/2)
if (!antithetic) v <- runif(R/2) else v <- 1 - u
u <- c(u, v)
cdf <- numeric(length(x)) for (i in 1:length(x)) {
g <- x[i] * exp(-(u * x[i])^2 / 2)
cdf[i] <- mean(g) / sqrt(2 * pi) + 0.5 }
cdf }
library(stringr)
library(dplyr)
library(tm)
library(RTextTools)
library(wordcloud)
library(DT)
library(ROCR)
library(ggplot2)
setwd("~/Documents/CUNYMSDA/Data 607/CUNYDATA607/Project 4")
projectjunk <- VCorpus(DirSource("spam_2"))
projectgood <- VCorpus(DirSource("easy_ham"))
## update headers into 1 and 0 to differentiate for processing
meta(projectjunk, "spam") <- 1
meta(projectgood, "spam") <- 0
projectall <- c(projectjunk, projectgood)
##emails <- tm_map(emails, content_transformer(function(x) iconv(x, to = 'UTF-8-MAC', sub = 'byte')))
##the following steps set everything to lowercase, remove any numbers, remove english stop words (built into tm) and remove all non-alpha numeric characters.
projectall <- tm_map(projectall, content_transformer(tolower))
projectall <- tm_map(projectall, removeNumbers)
projectall <- tm_map(projectall, removeWords, words = stopwords("en"))
projectall <- tm_map(projectall, content_transformer(function(x) str_replace_all(x, "[[:punct:]]|<|>", " ")))
projectall <- tm_map(projectall, stripWhitespace)
set.seed(6881)
projectall <- sample(projectall)
props_classes <- bind_rows(data.frame(dataset = "training", prop.table(table(spam = meta(projectall[1:1500]))),
stringsAsFactors = FALSE),
data.frame(dataset = "test", prop.table(table(spam = meta(projectall[1501:length(projectall)]))),
stringsAsFactors = FALSE))
colnames(props_classes)[3] <- "prop"
knitr::kable(props_classes)
dtm <- DocumentTermMatrix(emails, control = list(minWordLength = 2, minDocFreq = 5))
dtm
dtm <- removeSparseTerms(dtm, 0.95)
dtm
inspect(dtm[1:10, 1:5])
findFreqTerms(dtm, 1000)
dtm <- DocumentTermMatrix(emails, control = list(minWordLength = 2, minDocFreq = 5))
dtm
dtm <- DocumentTermMatrix(projectall, control = list(minWordLength = 2, minDocFreq = 5))
dtm
dtm <- removeSparseTerms(dtm, 0.95)
dtm
inspect(dtm[1:10, 1:5])
findFreqTerms(dtm, 1000)
container <- create_container(dtm,
labels = unlist(meta(emails)),
trainSize = 1:1500,
testSize = 1501:length(emails),
virgin = FALSE)
container <- create_container(dtm,
labels = unlist(meta(projectall)),
trainSize = 1:1500,
testSize = 1501:length(projectall),
virgin = FALSE)
models <- train_models(container, algorithms=c("SVM","TREE","MAXENT"))
results <- classify_models(container, models)
analytics <- create_analytics(container, results)
summary(analytics)
knitr::kable(select(analytics@algorithm_summary, SVM_PRECISION:SVM_FSCORE))
knitr::kable(analytics@ensemble_summary)
table(spam = meta(projectall[1:1500])))
table(spam = meta(projectall[1:1500]))
data.frame(dataset = "training", prop.table(table(spam = meta(projectall[1:1500]))),
stringsAsFactors = FALSE)
data.frame(dataset = "training", projectall[1:1500])
data.frame(dataset = "training", projectall[1:1500], stringasfactors = FASLE)
data.frame(dataset = "training", projectall[1:1500], stringasfactors = FALSE)
data.frame(dataset = "training", table(projectall[1:1500]), stringasfactors = FALSE)
data.frame(dataset = "training", table(meta(projectall[1:1500])), stringasfactors = FALSE)
data.frame(dataset = "training", table(spam=meta(projectall[1:1500])), stringasfactors = FALSE)
